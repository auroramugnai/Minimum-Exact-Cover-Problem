"""
This script processes CSV files generated by the EC_DWave.py script, extracting instance-based data and visualizing accuracy metrics.

Key features:
- Reads and parses CSV files into dictionaries.
- Extracts metadata from filenames.
- Processes all files in a selected directory.
- Plots accuracy data for two datasets (EC and MEC).
- Displays colored DataFrames highlighting solution states.
"""

import csv
import ast
import re
import os

import json
from matplotlib import pyplot as plt
import numpy as np
import pandas as pd
from termcolor import colored # to color a dataframe

from instances import all_solutions


def plot_accuracy(accuracy_EC_values, accuracy_MEC_values, instances, NUNITS, NREADS, NSAMPLES):
    """
    Plot accuracy metrics for two datasets (num_EC and num_MEC) across instances.

    Parameters
    ----------
    accuracy_EC_values : list of float
        Accuracy values for num_EC / (NREADS x NUNITS).
    accuracy_MEC_values : list of float
        Accuracy values for num_MEC / (NREADS x NUNITS).
    instances : list of int
        List of instance identifiers.
    NUNITS : int
        Number of units used in the experiment.
    NREADS : int
        Number of reads used in the experiment.
    NSAMPLES : int
        Number of samples used in the experiment.

    Returns
    -------
    None
        Displays a line plot with labeled data points.

    Notes
    -----
    - Each line represents accuracy values for one of the datasets (EC or MEC).
    - Data points are labeled with their corresponding accuracy values.
    """
    plt.rcParams.update({'font.family': 'Sans-serif', 'font.size': 14})

    # Plot data
    plt.figure(figsize=(10, 6))
    plt.title(f"Accuracy\n NUNITS = {NUNITS}, NREADS = {NREADS}, NSAMPLES = {NSAMPLES}")

    plt.plot(instances, accuracy_EC_values, label='num_EC / NREADS x NUNITS', 
             marker='x', color='r')
    plt.plot(instances, accuracy_MEC_values, label='num_MEC / NREADS x NUNITS', 
             marker='x', color='b')

    # Add text labels above each point
    for (i, value_EC, value_MEC) in zip(instances, accuracy_EC_values, accuracy_MEC_values):
        plt.text(i, value_EC, f'{value_EC:.2f}', ha='center', va='bottom', clip_on=True)
        plt.text(i, value_MEC, f'{value_MEC:.2f}', ha='center', va='bottom', clip_on=True)

    plt.xticks(instances)
    plt.xlabel('Instance')
    plt.ylabel('Accuracy [%]')
    plt.legend()
    plt.grid(True)
    plt.show()

def read_custom_csv(file_path):
    """
    Parse a custom-formatted CSV file into a list of dictionaries.

    Parameters
    ----------
    file_path : str
        Path to the CSV file.

    Returns
    -------
    list of dict
        Each dictionary contains:
        - 'state': list of int, parsed state values.
        - 'label': str, the label for the entry.
        - 'num_occurrences': int, occurrence count.
    """
    data = []
    with open(file_path, mode='r', newline='', encoding='utf-8') as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            parsed_row = {
                'state': ast.literal_eval(row['state']),
                'label': row['label'],
                'num_occurrences': int(row['num_occurrences'])
            }
            data.append(parsed_row)
    return data

def extract_filename_data(filename):
    """
    Extract metadata from a filename with a specific format.

    Parameters
    ----------
    filename : str
        Filename to parse, expected to match the pattern.

    Returns
    -------
    dict
        Extracted data:
        - 'date': str, date in MM-DD format.
        - 'time': str, time in HHhMMmSSs format.
        - 'instance': int, instance identifier.
        - 'NUNITS': int, number of units.
        - 'NREADS': int, number of reads.
        - 'NSAMPLES': int, number of samples.

    Raises
    ------
    ValueError
        If the filename does not match the expected format.
    """
    pattern = r"(?P<date>\d{2}-\d{2})@(?P<time>\d{2}h\d{2}m\d{2}s)_EC_instance(?P<instance>\d+)_NUNITS(?P<NUNITS>\d+)_NREADS(?P<NREADS>\d+)_NSAMPLES(?P<NSAMPLES>\d+)\.csv"
    match = re.match(pattern, filename)
    if not match:
        raise ValueError("Filename does not match the expected format")

    return {
        'date': match.group('date'),
        'time': match.group('time'),
        'instance': int(match.group('instance')),
        'NUNITS': int(match.group('NUNITS')),
        'NREADS': int(match.group('NREADS')),
        'NSAMPLES': int(match.group('NSAMPLES'))
    }

def process_files_in_directory(directory_path):
    """
    Process all CSV files in a directory, extracting metadata and content.

    Parameters
    ----------
    directory_path : str
        Path to the directory containing the files.

    Returns
    -------
    list of dict
        Each dictionary includes:
        - 'instance': int, instance identifier from the filename.
        - 'filename_data': dict, metadata extracted from the filename.
        - 'csv_data': list, parsed CSV content.

    Notes
    -----
    - Only processes `.csv` files.
    - Skips files with invalid names or formats.
    - Results are sorted by instance identifier.
    """
    results = []
    instance_files = {}

    for file_name in os.listdir(directory_path):
        if file_name.endswith(".csv"):
            try:
                extracted_data = extract_filename_data(file_name)
                instance_files[extracted_data['instance']] = {
                    'file_name': file_name,
                    'extracted_data': extracted_data
                }
            except ValueError:
                print(f"Skipping invalid file: {file_name}")

    for instance, file_info in instance_files.items():
        file_path = os.path.join(directory_path, file_info['file_name'])
        csv_data = read_custom_csv(file_path)
        results.append({
            'instance': instance,
            'filename_data': file_info['extracted_data'],
            'csv_data': csv_data
        })

    results.sort(key=lambda x: x['instance'])
    return results

def print_dictionary(d):
    """
    Print key-value pairs of a dictionary.

    Parameters
    ----------
    d : dict
        Dictionary to print.

    Returns
    -------
    None
    """
    for key, value in d.items():
        print(f"{key}: {value}")

def get_labels_from_directory(directory_path):
    """
    Retrieve folder names (labels) from a specified directory.

    Parameters
    ----------
    directory_path : str
        Path to the directory.

    Returns
    -------
    list of str
        List of folder names.
    """
    return [name for name in os.listdir(directory_path) if os.path.isdir(os.path.join(directory_path, name))]

# ************************************************************************
# *************************** MAIN ***************************************
# ************************************************************************
if __name__ == "__main__":

    # Get all the folders present in the directory
    labels = get_labels_from_directory("./")
    labels.remove("__pycache__")
    
    # If there are labels, allow the user to choose one
    if len(labels) == 1:
        selected_label = labels[0]
        all_data = process_files_in_directory(selected_label)

    elif labels:
        print("Select one of the following labels (folders):")
        for i, label in enumerate(labels, 1):
            print(f"{i}. {label}")
        
        # Ask the user to choose a label
        while True:
            try:
                user_choice = int(input(f"Choose a number from 1 to {len(labels)}: "))
                if 1 <= user_choice <= len(labels):
                    selected_label = labels[user_choice - 1]
                    print(f"\nYou have selected the folder: {selected_label}")
                    break
                else:
                    print("Invalid choice, please try again.")
            except ValueError:
                print("Please enter a valid number.")
        
        # Process the files with the selected label
        all_data = process_files_in_directory(selected_label)

    else:
        print("No folders found in the directory.")

    # ----------------------------- PRINT DATA -----------------------------------
    instances = []
    for data in all_data:
        print("-" * 42)

        print("Instance:", data['instance'])
        instances.append(data['instance'])
        print_dictionary(data['filename_data'])

        #----------    Print the dataframe with colors   ------------
        solutions_str = [str(s) for s in all_solutions[data['instance']]]
        df = pd.DataFrame(data['csv_data'], dtype=str)
    
        # Define a function that colors arrays in green if they are a solution.
        color_solutions = lambda x: (colored(x, None, 'on_green') 
                                     if x in solutions_str
                                     else colored(x, 'white', None))

        df['state'] = df['state'].map(color_solutions)

        # Reset columns or they will be shifted.
        df.columns =  [colored('state', 'white', None)] + ["label", "num_occurrences"]

        print(df)    

    # ----------------------------- ACCURACY PLOT -----------------------------------

    # Build the complete path to the JSON file
    json_file_path = os.path.join(selected_label, f'{selected_label}_accuracy_values.json')
    
    # Check if the file exists
    if not os.path.exists(json_file_path):
        print(f"The file {json_file_path} was not found.")
    else:
        # Load accuracy data from the JSON file
        with open(json_file_path, 'r') as file:
            data = json.load(file)
            # Multiply each value by 100
            accuracy_EC_values = [value * 100 for value in data['accuracy_EC_values']]
            print(accuracy_EC_values)
            accuracy_MEC_values = [value * 100 for value in data['accuracy_MEC_values']]
            print(accuracy_MEC_values)

        # Plot the accuracy data
        NUNITS = all_data[0]["filename_data"]["NUNITS"]
        NREADS = all_data[0]["filename_data"]["NREADS"]
        NSAMPLES = all_data[0]["filename_data"]["NSAMPLES"]

        
        plot_accuracy(accuracy_EC_values, accuracy_MEC_values, instances, 
                      NUNITS, NREADS, NSAMPLES)
